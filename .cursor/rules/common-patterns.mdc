---
alwaysApply: true
---

# Common Implementation Patterns

## Package Management
- **USE 'pnpm' not 'npm'** for all package management operations
- **DO NOT use 'pnpm dev' or 'pnpm run dev'** - use appropriate WXT commands
- Use `pnpm install` for dependency installation
- Use `pnpm add` for adding new dependencies
- Use `pnpm remove` for removing dependencies

## Message Passing Pattern
```typescript
// Define message types
interface AutomationMessage {
  type: 'EXECUTE_ACTION';
  payload: ActionSequence;
}

// Background script listener
browser.runtime.onMessage.addListener((message: AutomationMessage) => {
  // Handle message
});
```

## Content Script React Integration
```typescript
// Safe React root creation in content scripts
const createReactRoot = (container: Element) => {
  const root = ReactDOM.createRoot(container);
  return root;
};
```

## WXT Framework Patterns
```typescript
// WXT auto-imports browser API
// No need for webextension-polyfill import in most cases
await browser.storage.sync.set({ key: value });

// WXT entrypoint exports
export default defineContentScript({
  matches: ['*://*/*'],
  main() {
    // Content script logic
  },
});

// WXT background script
export default defineBackground(() => {
  // Background script logic
});
```

## Cross-browser API Usage
```typescript
// WXT provides browser API automatically
// For complex cases, still use webextension-polyfill
import browser from 'webextension-polyfill';

await browser.storage.sync.set({ key: value });
```

## Action Queue Pattern
```typescript
interface AutomationAction {
  type: string;
  target: string;
  value?: string;
  delay?: number;
}

class ActionQueue {
  private queue: AutomationAction[] = [];
  
  async execute() {
    for (const action of this.queue) {
      await this.performAction(action);
      if (action.delay) {
        await new Promise(resolve => setTimeout(resolve, action.delay));
      }
    }
  }
}
```

## String Management Pattern
```typescript
// NavigationUrls class example
class NavigationUrls {
  static readonly JOTFORM_BASE = 'https://www.jotform.com' as const;
  static readonly FORM_BUILDER = '/build' as const;
  
  static getFormUrl(formId: string): string {
    return `${this.JOTFORM_BASE}/form/${formId}`;
  }
}

// ElementSelectors class example
class ElementSelectors {
  static readonly FORM_SUBMIT = '[type="submit"]' as const;
  static readonly TEXT_INPUT = 'input[type="text"]' as const;
}
```

## Error Handling Pattern
```typescript
class StringError extends Error {
  constructor(
    message: string,
    public readonly type: string,
    public readonly originalValue: string
  ) {
    super(message);
    this.name = 'StringError';
  }
}
```

These patterns provide reusable, tested approaches for common browser extension and AI automation scenarios while following strict string management and package management requirements.